

## DB

### ORM(Object Relational Mapping)

* 객체와 관계와의 설정
* 객체와 관계형 DB를 Mapping해준다.
* 객체와 테이블을 Mapping하기 때문에 SQL을 직접 날리는 것이 아니라 마치 자바에서 라이브러리 사용하듯이 사용하면 된다.
* 객체와 관계형 데이터에비스와의 설정을 자동으로 해준다.
* 관계형 데이터베이스의 데이터를 객체형 데이터처럼 사용할 수 있다.
* JPA, Hibernate, MyBatis
* 장점
  * 객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 집중할 수 있게 도와준다.
  * 선언, 할당, 종료 같은 부수적인 코드가 줄어든다.
  * 재사용 및 유지 보수의 편리성이 증가한다.
  * DBMS에 대한 종속성이 줄어든다.
  * 절차적, 순차적 접근이 아닌 객체 지향적 접근으로 인해 생산성이 증가한다.
* 단점
  * 모든 기능을 ORM으로만 작성하기에는 쿼리가 복잡해지면 쓰기 어렵다.
  * 많은 수의 레코드를 잦은 빈도로 벌크 수행
  * ORM으로만 완벽하게 서비스를 구현하기가 어렵다.
  * 프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어렵다.

### MySQL 엔진

* InnoDB
  * 기본값 스토리지 엔진
  * 트랜잭션 safe, 커밋과 롤백, 데이터 복구 기능을 제공한다.
  * row-level locking을 제공한다.
  * 데이터를 clusterd index에 저장하여 pk기반 query의 I/O 비용을 줄인다.
  * fk제약을 제공하여 데이터 무결성을 보장한다.
* MyISAM
  * 트랜잭션을 지원하지 않는다.
  * 테이블 단위의 locking을 제공한다.
  * 특정 세션이 테이블을 변경하는 동안 테이블 단위로 lock이 잡힌다.
* Archive
  * 로그 수집에 적합한 엔진
  * 데이터가 메모리 상에서 압축되고 압축된 상태로 디스크에 저장된다.
  * row-level locking이 가능하다.
  * 한번 insert된 데이터는 update/delete가 불가능하다.
  * 인덱스를 지원하지 않는다.
  * 거의 가공하지 않을 윈시 로그 데이터를 관리하는데 효율적이고, 테이블 파티셔닝도 지원한다.
  * 트랜잭션은 지원하지 않는다.

### 인덱스

* RDBMS에서 검색 속도를 높이기 위해 사용하는 기술
* 색인
* 해당 테이블의 컬럼을 색인화(따로 파일로 저장)하여 검색시 테이블 전체를 full scan 하는 것이 아니라 색인화 되어있는 index 파일을 검색하여 검색 속도를 빠르게 한다.
* B+ 트리로 저장된다.
* index로 설정한 컬럼 값이 변경되거나 추가되면, 인덱스 역시 변경된다. 따라서 적절하게 인덱스를 설정해야 한다.
* 데이터의 삽입, 삭제가 빈번한 경우 index의 성능이 떨어진다. 매번 B+트리를 수정해야 하기 때문이다.
* index가 데이터베이스 공간을 차지하기 때문에 추가적인 공간이 필요하다.(10%)
* index는 B+ 트리에서 key값으로 column의 값을 저장하고 있기 때문에 SELECT 조회 시 index로 설정한 데이터만 조회한다면 테이블을 조회하지 않고 인덱스만 조회한다. (covering index)
* index를 생성하는데 시간이 많이 소요될 수 있다.
* SELECT의 WHERE / JOIN / GROUP BY 시에만 인덱스가 사용되며 SELECT의 검색 속도를 빠르게 하는것이 목적이다.
* WHERE의 타겟이 되는 컬럼을 인덱스로 만드는 것이 좋다.
* 데이터 중복도가 높은 컬럼은 인덱스로 만들어도 효과가 없다.
* 외래키가 사용되는 컬럼은 인덱스를 생성해 주는 것이 좋다.
* 사용하지 않는 인덱스는 제거하는 것이 좋다.

### 정규화

* 관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화 하는 프로세스이다.
* 관계를 재구성하여 작고 잘 조직된 관계를 생성하는 것에 있다.
* 성능상의 이유로 비정규화 될 수 있다.

### 트랜잭션
* 데이터베이스 관리 시스템에서 상호 작용의 단위이다.
* 트랜잭션은 ACID를 보장해야 한다.
* 원자성(Atomicity) : 한 트랜잭션 내에서 실행한 작업들은 하나의 작업으로 간주한다. 모두 성공하거나, 모두 실패되어야 한다.
* 일관성(Consistency) : 모든 트랜잭션은 일관성있는 데이터베이스 상태를 유지한다. DB에서 정한 무결성 원칙을 항상 만족한다.
* 고립성(Isolation) : 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 격리해야 한다.
* 영구성(Durability) : 트랜잭션을 성공적으로 마치면 그 결과가 항상 저장되어야 한다.

### DB Isolation Level
* 격리성 관련 문제점

##### 1.Dirty Read
* 커밋되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상이다.
* 어떤 트랜잭션에서 아직 실행이 끝나지 않은 다른 트랜잭션에 의해 변경 사항을 보게 되는 경우이다.

##### 2.Non-Repeatable Read
* 한 트랜잭션에서 같은 SQL을 두 번 수행할 때, 두 SQL의 결과가 다르게 나타나는 비 일관적인 현상이다.
* 한 트랜잭션이 수행중일 때 다른 트랜잭션이 값을 수정, 삭제함으로써 나타난다.

##### 3.Phantom Read
* 한 트랜잭션에서 같은 SQL을 두 번 수행할 때, 첫번째 SQL에서 없던 데이터가 두번째 SQL에서 나타나는 현상이다.
* 한 트랜잭션이 수행중일 때 다른 트랜잭션이 값을 삽입함으로써 나타난다.

#### 트랜잭션 격리 수준
* 트랜잭션에서 일관성이 없는 데이터를 허용하도록 하는 수준이다.
* 데이터베이스는 ACID 같이 트랜잭션이 원자적이면서도 독립적인 수행을 하도록 한다.
* 4단계의 격리 수준을 나누었다.
* 단계를 내려갈수록 격리 수준이 높아져서 언급된 이슈는 적게 발생하지만, 동시 처리 성능은 떨어진다.
* 응답성을 높이기 위해 단계를 올라간다면, 잘못된 값이 처리 될 여지가 있다.
* 트랜잭션이 발생하면 Lock이 걸리는데, SELECT시에는 공유 Lock, CREATE/INSERT/DELETE 시에는 배타적 Lock이 걸린다.

##### 1.Read Uncommitted(레벨 0)
* `SELECT가 수행되는 동안 해당 데이터에 공유 Lock이 걸리지 않는다.`
* 트랜잭션에 처리중인 혹은 아직 커밋되지 않은 데이터를 `다른 트랜잭션이 읽는 것을 허용`한다.
* 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 아직 완료되지 않은(Uncommitted 혹은 Dirty) 트랜잭션이지만 변경된 데이터인 B를 읽을 수 있다.
* 데이터베이스의 일관성을 유지할 수 없다.
* Dirty Read, Non-Repeatable Read, Phantom Read 발생

##### 2.Read Committed(레벨 1)
* `SELECT가 수행되는 동안 해당 데이터에 공유 Lock이 걸린다.`
* 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 된다.
* 커밋이 이루어진 트랜잭션만 조회할 수 있다.
* 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 `다른 사용자는 해당 데이터에 접근할 수 없다.`
* SQL Server가 Default로 사용하는 단계이다.
* Non-Repeatable Read, Phantom Read 발생

##### 3.Repeatable Read(레벨 2)
* 트랜잭션이 완료될 때까지 `SELECT가 사용하는 모든 데이터에 공유 Lock이 걸린다.`
* 트랜잭션이 범위 내에서 조회한 데이터의 내용이 항상 동일함을 보장한다.
* 다른 사용자는 그 영역에 해당되는 데이터에 대한 `수정이 불가능` 하다.
* Phantom Read 발생

##### 4.Serializable(레벨 3)
* 트랜잭션이 완료될 때까지 `SELECT가 사용하는 모든 데이터에 공유 Lock이 걸린다.`
* 완벽한 읽기 일관성 모드를 제공한다.
* 가장 엄격한 격리 수준이다.
* 다른 사용자는 그 영역에 해당되는 데이터에 대한 `수정 및 입력이 불가능`하다.
* 위 3가지 문제점을 모두 커버 가능하다.
* 동시 처리 성능은 급격히 떨어질 수 있다.

### Partitioning(파티셔닝)

* 수직 파티셔닝
* 큰 테이블이나 인덱스를 관리하기 쉬운 단위로 분리하는 방법을 의미한다.
* 물리적인 파티셔닝으로 인해 전체 데이터의 훼손 가능성이 줄어들고 데이터 가용성이 향상된다.
* 큰 테이블을 제거하여 관리를 쉽게 해준다.
* 특정 DML과 쿼리의 성능을 향상시킨다.
* 주로 대용량 데이터 Write 환경에서 효율적이다.
* 많은 데이터 삽입이 있는 OLTP(Online Transaction Processing) 시스템에서 삽입 작업들을 분리된 파티션들로 분산시켜 경합을 줄인다.
* 테이블간 join에 대한 비용이 증가한다.
* 테이블과 인덱스를 별도 파티션 할 수는 없다. 테이블과 인덱스를 같이 파티셔닝해야 한다.

### Sharding(샤딩)

* 수평 파티셔닝
* 대용량의 데이터를 처리하기 위해 테이블을 수평 분할하여 데이터를 분산 저장하고 처리하는 것을 의미한다.
* 같은 타입의 데이터를 다수의 데이터베이스에 쪼개서 저장하는 것
* 샤딩 알고리즘이 매우 쉽게 일반화가 가능하기에 애플리케이션 레벨이나 데이터베이스 레벨이서 구현이 가능하다.

### Replication(리플리케이션)

* 두 개 이상의 DBMS 시스템을 Master/Slave로 나눠서 동일한 데이터를 저장하는 방식
* Master에는 데이터의 수정 사항을 반영만 하고 Replication을 하여 Salve에 실제 데이터를 복사한다.
* 삽입/수정/삭제는 Master가 담당하고 조회는 Slave가 담당해서 성능 향상 효과를 얻을 수 있다.
* 로그 기반 복제
  * Statement Based : SQL을 복사하여 진행
  * Row Based : SQL에 따라 변경된 Row만 기록하는 방식
  * Mixed : 기본적으로 statement Based로 진행하면서 필요에 따라 Row Based를 사용한다.

### MongoDB

* 도큐먼트 지향 데이터베이스 시스템이다.
* NoSQL
* 똑같은 조건으로 설계했을 시 RDBMS보다 빠르다.
* 트랜잭션을 지원하지 않는다.
* 도큐먼트의 집합을 컬렉션이라고 한다. = RDBMS에서 테이블
* Join을 지원하지 않는다.
* 데이터 갱신 및 입력이 바로 디스크에 쓰이지 않는다.(비동기식) 따라서 데이터가 유실될 가능성이 있다.
* 자체적으로 스케일 아웃을 지원한다.

### Redis

* 인 메모리 데이터베이스
* NoSQL
* 키-값 구조
* C 코드로 개발되었다.
* 데이터를 디스크에 저장하기 때문에 데이터 유실 위험이 memcached에 비해 적다.
* 클러스터링을 지원하지 않는다.
* 샤딩을 통해 확장한다.
* 데이터를 저장하는 방식
  * snapshotting
    * save
      * 순간적으로 redis를 정지시키고, 그 때의 스냅샷을 디스크에 저장한다.
    * blocking
      * 별도의 프로세스를 띄운후, 그 당시의 메모리 스냅샷을 디스크에 저장하며 redis는 정상적으로 작동한다.
  * AOF(Append On File)
    * redis의 모든 write/update 연산 자체를 모두 log 파일에 기록해 두었다가 서버가 재 시작될 때 기록된 로그를 통해 데이터를 복구한다.
    * 기본적으로 non-blocking call이다.
* Single Thread로 작동한다.
* Single Thread로 작동하기 때문에 여러 명령을 script로 한 번에 요청할 경우 transaction level serializable과 같은 효과를 얻을 수 있다.

### Memcached

* DB / API 통신을 줄이기 위해 데이터를 캐싱 처리하는데에 사용하면 좋은 캐시이다.
* 트래픽이 몰려도 응답 속도는 안정적인 편이다.
* Redis에 비해 데이터 타입과 API가 다양하지 않다.
* Key-Value만 지원한다.
* 캐시 솔루션이다. 레디스는 여기에 저장소의 개념이 추가된 것이다.

### MariaDB

* MySQL이 오라클로 넘어간 뒤 불확실한 라이선스 문제를 해결하기 위해 나온 오픈 소스 DBMS이다.
* MySQL의 대체제, 사용법이 같다.

### Datasocurce

* 커넥션 풀의 커넥션을 관리하기 위한 인터페이스이다. (javax.sql.DataSource)
* Datasource를 구현한 대표적인 예가 hikariCP이다. [HikariDataSource](https://github.com/brettwooldridge/HikariCP/blob/dev/src/main/java/com/zaxxer/hikari/HikariDataSource.java#L40)
* 데이터소스 객체를 통해서 필요한 커넥션을 획득, 반납한다.
* JNDI(Java Naming and Directory Interface) Server를 통해 이용된다.