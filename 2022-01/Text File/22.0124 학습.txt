### HikariCP

* 스프링 부트 2.0의 기본 jdbc cp이다.

## Java

### Java 8 변경 사항

* 인터페이스에 디폴트 메소드 추가
* 스트림 api
* 람다
* 함수형 프로그래밍
* Optional

### Interface(인터페이스)

* 클래스들이 구현해햐 하는 동작을 지정하는데 사용되는 추상형
* 규약, 규제
* 추상 클래스의 극단적인 경우
* 클래스와 달리 다중 상속(다중 구현)이 가능하다.
* 객체의 내부 구조를 알 필요 없이 인터페이스의 메소드만 알고 있으면 된다는 장점
* 다형성을 이용한 인터페이스의 구현 객체를 손쉽게 교체할 수 있다.
* 자바 8에서 인터페이스가 가질 수 있는 것
  * 상수 필드(public static final) : 기존, 생략 가능
  * 추상 메소드(public abstract) : 기존, 생략 가능
  * 디폴드 메소드(public default) : 새로 추가됨
    * 이전에 개발한 구현 클래스를 그대로 사용하지 않고 변경하지 않으면서, 새롭게 개발하는 클래스는 디폴트 메소드를 활용해 새로운 기능을 만들 수 있다. 

### 다형성

* 하나의 메소드나 클래스가 상황에 따라 다양한 방법으로 동작하는 것을 의미한다.
* 오버로딩(Overloading)은 다형성의 가장 대표적인 예
* 다형성의 조건
  * 공통의 부모
  * 공통의 메소드 재정의
  * 부모 타입의 변수로 호출

### Generic(제네릭)

* 다양한 타입의 객체들을 다루는 메소드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해 주는 기능이다.
* 클래스 내부에서 사용할 데이터 타입을 나중에 인스턴스를 생성할 때 확정하는 것을 말한다.
* 타입 안정성을 제공한다.
* 타입 체크와 형 변환을 생략할 수 있으므로 코드가 간결해진다.

### mutable & immutable

* mutable
  * 변경 가능 객체
  * 상태를 바꿀 수 있는 객체
  * 최초 생성 이후에도 자유롭게 값 변겨 가능
* immutable
  * 변경 불가 객체
  * 상태를 바꿀 수 없는 객체
  * 최초 생성 이후로는 값 변경 불가

### OOP(Object-Oriented Programming, 객체 지향 프로그래밍)

* 프로그램을 수 많은 객체라는 기본 단위로 나누고 이 객체들의 상호 작용으로 프로그램을 서술하는 방식
* 객체들을 데이터 묶음 뿐만 아니라 하나의 역할을 수행하는 메소드와 데이터의 묶음
* 큰 문제를 작게 쪼개는 것이 아니라, 먼저 작은 문제들을 해결할 수 있는 객체들로 만든 뒤, 이 객체들을 조합해서 큰 문제를 해결하난 상향식(Buttom up) 해결법 도입
* 캡슐화(Encapsulation)
  * 프로그램의 세부 구현을 외부로 드러나지 않도록 특정 모듈(클래스) 내부로 감추는 것이다.
  * 접근 제어 지시자를 통해 외부에서 접근을 제어한다.
* 상속(Inheritance)
  * 자식 클래스가 부모 클래스의 특성과 기능을 그대로 물려받는 것을 말한다.
  * 재정의를 통해 자식 클래스에서 상속받은 기능만들 재 정의해 사용이 가능하다.
* 다형성(Polymorphism)
  * 하나의 변수, 함수 등이 상황에 따라 다른 의미로 해석될 수 있다.
  * 오버로딩

### Reflection

* 객체를 통해 클래스의 정보를 분석해 내는 프로그램 기법
* 자바는 동적으로 객체를 생성하는 기술이 없다. 그래서 동적으로 인스턴스를 생성하는 Reflection으로 그 역할을 대신하게 된다.
* Reflection은 구체적인 클래스 타입을 알지 못해도, 그 클래스의 메소드, 타입, 변수들을 접근할 수 있도록 해주는 자바 API이다.

### Annotation

* 자바 소스 코드에 추가하여 사용할 수 있는 메타데이터의 일종이다.
* @기호를 붙여서 사용한다.
* JDK 1.5버전 이상에서 사용 가능하다.
* CompileTime, Runtime시에 해석될 수 있다.
* 클래스 파일에 포함되어 컴파일러에 의해 생성된 후 JVM에 포함되어 작동한다.
* @Target으로 어노테이션이 적용할 위치를 선택한다.
* @Retention으로 컴파일러가 어노테이션을 다루는 방법을 설정한다.

### Enum

* 열거 타입, 변수를 선언할 때 변수 타입으로 사용할 수 있다.
* IDE의 지원을 받을 수 있다.(자동 완성, 오타, 텍스트 리팩토링)
* 허용 가능한 값들을 제한할 수 있다.
* 리팩토링시 변경 범위가 최소화된다. 내용의 추가가 필요하더라도, Enum 코드외에 수정할 필요가 없다.
* 완전한 기능을 갖춘 클래스이다.

### 접근 제어 지시자

| 지시자    | 클래스 내부 | 동일 패키지 | 상속받은 클래스 | 이외의 영역 |
| --------- | ----------- | ----------- | --------------- | ----------- |
| private   | :o:         | :x:         | ❌               | ❌           |
| default   | :o:         | :o:         | :x:             | ❌           |
| protected | :o:         | :o:         | :o:             | ❌           |
| public    | :o:         | :o:         | :o:             | ⭕️           |

* private : 클래스 내부(메소드)에서만 접근을 허용한다.
* default : 클래스 내부와 동일 패키지에서만 접근을 허용한다.
* protected : 클래스 내부와 동일 패키지 상속받은 클래스에서만 접근이 가능하다.
* public : 어디서든 접근이 가능하다.

### String, StringBuilder, StringBuffer

* String은 immutable, private final char[] 형태
* immutable인 이유 : 퍼포먼스, 동시성, GC
* StringBuilder, StringBuffer은 mutable
* StringBuffer는 Thread safe, StringBuilder는 Thread safe하지 않다. 따라서 Multi Thread 환경에서는 StringBuffer를 사용해야 한다.

### Collection

* 데이터를 저장하는 기본적인 자료구조들을 한 곳에 모아 관리하고 편하게 사용하기 위해서 제공한다.
* 모든 Collection의 상위 인터페이스로써 Collection이 갖고 있는 핵심 메소드를 선언한다.
* List
  * 순서가 있는 데이터의 집합이다.
  * 데이터의 중복을 허용한다.
  * LinkedList : 양방향 포인터 구조로 데이터의 삽입, 삭제가 빈번할 경우 빠른 성능을 보장한다. 스택, 큐, 양방향 큐 등을 만들기 위한 용도로 사용된다.
  * ArrayList : 상당히 빠르고 크기를 마음대로 조절할 수 있는 배열이다. 단방향 포인터 구조로 자료에 대한 순차적인 접근에 강점이 있다.
* Set
  * 순서가 없는 데이터의 집합이다.
  * 데이터의 중복을 허용하지 않는다.
  * HashSet : 가장 빠른 임의 접근 속도를 가진다. 순서를 전혀 예측할 수 없다.
  * TreeSet : 정렬된 순서대로 보관하며 정렬 방법을 지정할 수 있다.
  * LinkedHashSet : 추가된 순서, 또는 가장 최근에 접근한 순서대로 접근이 가능하다.
* Map
  * 키-값 쌍으로 이루어진 데이터의 집합이다.
  * 순서는 유지되지 않고, 키는 중복을 허용하지 않는다. 값은 중복을 허용한다.
  * HashMap : Map 인터페이스를 구현하기 위해 HashTable을 사용한 클래스, 중복을 허용하지 않고 순서를 보장하지 않는다. 키와 값으로 null이 허용된다.
  * TreeMap : 이진검색트리의 형태로 키와 값이 쌍으로 이루어진 데이터를 저장한다. 정렬된 순서로 키, 값 쌍을 저장하므로 빠른 검색이 가능하다. 저장시 정렬을 하기 때문에 저장시간이 다소 오래걸린다.
  * HashTable : HashMap보다 느리지만 동기화가 지원된다. 키와 값으로 null이 허용되지 않는다.
  * LinkedHashMap : 기본적으로 HashMap을 상속받아 HashMap과 매우 흡사하다. Map에 있는 엔트리들이 연결 리스트가 유지되므로 입력한 순서대로 반복이 가능하다.

## JVM(Java Virtual Machine)

- 자바 가상 머신
- 자바 애플리케션을 클래스 로더를 통해 읽어 들어 자바 API와 함께 실행하는 것이다.
- 자바 바이트 코드를 실행할 수 있는 주체이다.
- 인터프리터나 JIT컴파일 방식으로 다른 컴퓨터 위에서 자바 바이트 코드를 실행할 수 있도록 구현한다.
- 자바 바이트 코드는 플랫폼에 독립적이다.
- 이론적으로 모든 자바 프로그램은 CPU나 운영체제의 종류와 무관하게 동작할 것을 보장한다.
- 스택 기반, 대다수의 명령어가 스택 선두에서 피연산자를 택하고 다시 스택에 넣는다.
- 포인터를 지원하지만, C처럼 주소 값을 임의로 조작이 가능한 포인터 연산을 지원하지 않는다.
- GC를 사용해 자원을 관리한다.
- 메모리 관리가 가능하다.

### Class Loader

* 각 소스코드 파일을 오브젝트 파일로 변환시켜주는 역할을 한다.
* Loader(로더)
  * 목적 프로그램(기계어 파일)을 실행 가능한 파일로 변환하기 위해 컴퓨터의 주 기억 장소를 할당(Allocation)하거나, 여러개의 목적 프로그램을 연계 편집하여 CPU가 처리할 수 있는 프로그램으로 변환시킨다.
  * 프로그램을 실행하기 위하여 프로그램을 보조 기억 장치로부터 컴퓨터의 주 기억 장치에 올려 놓는 작업을 수행
  * 목적 프로그램들 끼지 연결(Linking)시키거나, 주 기억 장치를 재배치(Relocation)하는 증 포괄적인 작업을 수행
  * 할당(Allocation) -> 연결(Linking) -> 재배치(Relocation) -> 적재(Loading) 순으로 진행
* Linker : 모든 오브젝트 파일들을 하나의 오브젝트 파일로 합친다.
* JVM내로 Class(.class)를 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈이다.
* Runtime 시점에 Dynamic으로 Class를 Load한다.
* jar 파일 내 저장된 Class들을 JVM 위에 올리고, 사용하지 않는 Class들은 메모리에서 삭제한다.
* class의 instance를 생성하면 Class Loader를 통해 메모리에 Load하게 된다.
* Java는 Dynamic Code
* Compiletime이 아니라 Runtime시에 참조한다. 즉 Class를 처음 참조할 때, 해당 Class를 Load하고 Link한다.

### Runtime Data Areas

* JVM이 프로그램을 수행하기 위해 OS로부터 별도로 할당 받은 메모리 공간을 의미한다.
* PC Register
  * CPU는 명령어를 수행하는 동안 필요한 정보를 Register라고 하는 CPU내의 기억장치를 사용한다.
  * Stack - Base로 동작한다.
  * 각 쓰레드별로 하나씩 존재하며, 현재 수행중인 JVM 명령어의 주소를 가지게 된다.
  * 만약 Native Method를 수행한다면 PC Register는 undefined 상태가 된다.
  * PC Register에 저장되는 명령어의 주소는 Native Pointer 일 수도 있고, Method ByteCode일 수도 있다.
  * Native Method를 수행할 때에서는 JVM을 거치지 않고 API를 통해 바로 수행하게 된다.
* JVM Stack
  * JVM Stack은 Thread의 수행 정보를 Frame를 통해서 저장하게 된다.
  * Thread가 시작될 때 생성되며, 각 쓰레드별로 생성이 되기 때문에 다른 쓰레드에는 접근할 수 없다.
  * 메소드가 호출되면 메소드와 메소드 정보는 스택에 쌓이게 되며 메소드 호출이 종료될 때 스택 point에서 제거된다.
  * 메소드 정보는 해당 메소드의 매개변수, 지역변수, 임시변수, 주소(메소드 호출한 주소) 등을 저장하고, 메소드 종료시 메모리 공간이 사라진다.
* Native Method Stack
  * Java외의 언어로 작성된 Native Code들을 위한 스택, 즉 JNI(Java Native Interface)를 통해 호출되는 C/C++ 등의 코드를 수행하기 위한 Stack
* Method Area(Class Area, Static Area)
  * 모든 쓰레드가 공유하는 메모리 영역이다.
  * Method Area는 Class, Interface, Method, Field, Static 변수 등의 Byte Code 등을 보관한다.

* Heap
  * 인스턴스 또는 객체를 저장하는 공간이다.
  * 프로그램상에서 런타임시 다이나믹으로 할당하여 사용하는 공간이다.
  * .class를 이용해 인스턴스를 생성하면 Heap에 저장된다.
  * new 연산자로 생성된 인스턴스를 저장한다.
  * 초기 heap size는 64m이고 최대 heap size는 256m이다.
  * GC의 대상이 된다.
  * 성능 이슈를 일으키는 공간이다.
    * Permanent Generation
      * 생성된 인스턴스의 주소값이 저장된 공간이다.
    * New/Young Area
      * eden : 인스턴스들이 최초로 생성되는 공간
      * survivor 0/1 : eden에서 참조되는 인스턴스들이 저장되는 공간
    * Old
      * new Area에서 일정 시간 참조되고 살아남은 객체들이 저장되는 공간
      * eden 영역에서 인스턴스가 가득차게 되면 첫번째 GC가 발생한다.
      * eden 영역에 있는 값들을 Survivor 1영역에 복사하고, 이 영역을 제외한 나머지 영역의 객체를 삭제한다.
* Runtime Constant Pool
  * 각 클래스와 인터페이스의 상수, 메소드와 필드에 대한 모든 레퍼런스를 담고 있는 테이블이다.
  * 메소드나 필드의 실제 메모리상 주소를 찾을땐 해당 풀을 참조한다.

### Execution Engine

* Load된 Class의 바이트코드를 실행하는 Runtime Module이다.
* Class Loader를 통해 JVM내의 Runtime Data Areas에 배치된 ByteCode는 Execution Engine에 의해 실행되며, 실행 엔진은 자바 바이트코드를 명령어 단위로 읽어서 실행한다.
* 최초의 JVM은 인터프리터 방식이기 때문에 속도가 느린 단점이 있었지만, JIT 컴파일러 방식을 통해 이 점을 보완했다.
* JVM은 모든 코드를 JIT 컴파일러 방식으로 실행하지 않고, 인터프리터 방식을 사용하다가 일정한 기준을 넘어서면 JIT 컴파일러 방식으로 실행한다.

### 실행 과정

1. 프로그램이 실행되면 JVM은 OS로부터 이 프로그램이 필요로 하는 메모리를 할당받는다. JVM은 이 메모리를 용도에 따라 여러 영역(Rumtime Data Areas)으로 나누어 관리한다.
2. Java Compiler(Javac)가 Java SourceCode(.java)를 읽어들여 Java ByteCode(.class)로 변환한다.
3. Class Loader를 통해 class 파일들을 JVM으로 Loading한다.
4. Loading된 class 파일들은 Execution Engine을 통해 해석된다.
5. 해석된 ByteCode는 Runtime Data Areas에 배치되며 실질적인 수행이 이루어지게 된다. 이러한 과정속에서 필요에 따라 Thread Synchronization과 같은 GC 작업을 수행한다.

### JIT(Just In Time) Compiler

* Interpreter 방식의 단접을 보완하기 위해 도입된 컴파일러

* 인터프리터 방식으로 실행하다가 일정한 기준을 넘어서면 바이트코드 전체를 컴파일하여 네이티브 코드로 변환한다.

* 이후에는 더이상 인터프리터 방식으로 컴파일하지 않고, 네이티브 코드로 직접 실행한다.

* NativeCode는 Cache에 보관하기 때문에 한번 Compile된 Code는 빠르게 수행된다.

* JIT Compiler가 Compile하는 과정은 ByteCode를 Interpreting하는 방식보다 훨씬 오래 걸리므로 한 번만 실행되는 Code라면 Interpreter방식이 적절하다.